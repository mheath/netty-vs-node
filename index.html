<!DOCTYPE html>

<!--
  Google HTML5 slide template

  Authors: Luke MahÃ© (code)
           Marcin Wichary (code and design)
           
           Dominic Mazzoni (browser compatibility)
           Charles Chen (ChromeVox support)

  URL: http://code.google.com/p/html5slides/
-->

<html>
<head>
    <title>Presentation</title>

    <meta charset='utf-8'>
    <meta name="viewport" content="width=980">

    <script src='js/slides/slides.js'></script>
    <!--<script src="js/socket.io/socket.io.min.js"></script>-->
    <!--<script src="js/remote.js"></script>-->

    <script>
    </script>

</head>

<style>
	@font-face {
	    font-family: 'QlassikMediumRegular';
	    src: url('font/Qlassik-Medium/Qlassik_TB-webfont.eot');
	    src: url('font/Qlassik-Medium/Qlassik_TB-webfont.eot?#iefix') format('embedded-opentype'),
	         url('font/Qlassik-Medium/Qlassik_TB-webfont.woff') format('woff'),
	         url('font/Qlassik-Medium/Qlassik_TB-webfont.ttf') format('truetype'),
	         url('font/Qlassik-Medium/Qlassik_TB-webfont.svg#QlassikMediumRegular') format('svg');
	    font-weight: normal;
	    font-style: normal;

	}

	@font-face {
	    font-family: 'QlassikBoldRegular';
	    src: url('font/Qlassik-Medium/QlassikBold_TB-webfont.eot');
	    src: url('font/Qlassik-Medium/QlassikBold_TB-webfont.eot?#iefix') format('embedded-opentype'),
	         url('font/Qlassik-Medium/QlassikBold_TB-webfont.woff') format('woff'),
	         url('font/Qlassik-Medium/QlassikBold_TB-webfont.ttf') format('truetype'),
	         url('font/Qlassik-Medium/QlassikBold_TB-webfont.svg#QlassikBoldRegular') format('svg');
	    font-weight: normal;
	    font-style: normal;

	}

	article h1, article h3, article h2, article p, article li {
		font-family: 'QlassikBoldRegular';
	}
	
	article pre {
		line-height: 34px;
	}
	
	.center {
		display: block; 
		margin-left: auto; 
		margin-right: auto; 
	}
	.high {
		padding: 50px 0 0 0;
	}
	.mid {
		padding: 100px 0 0 0;
	}
	.low {
		padding: 150px 0 0 0;
	}
	.xlow {
		padding: 250px 0 0 0;
	}
</style>

<body style='display: none'>

<section class='slides layout-regular template-default'>

	
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Introduction ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article>
        <h1>
            Netty vs. Node.js
        </h1>

        <p>
            Mike Heath
            <br/>
            Tom Valletta
        </p>
    </article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Event Driven ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/apple_vs_orange.jpg" />
		<h2>Why Netty vs. Node.js?</h2>
	</article>

	<article>
		<h1>Netty</h1>
		<h2>...asynchronous event-driven network application framework...</h2>
	</article>

	<article>
		<h1>Node.js</h1>
		<h2>Evented I/O for V8 JavaScript.</h2>
	</article>

	<article>
		<h2>What does it mean to be event-driven?</h2>
	</article>

    <article class='fill'>
		<img src="images/Classic-Cars-1966-Ford-Mustang.jpg" />
	    <h3>Thread-per-connection Architecture</h3>
    </article>

	<article>
		<h3>Thread-per-connection Architecture</h3>
		<ul class="build">
			<li>Each network connection is handled by its own thread</li>
			<li>Each thread has its own stack for maintaining state</li>
			<li>Apache, Tomcat, JBoss, PHP, Rails, etc.</li>
		</ul>
	</article>

	<article>
		<h3>Thread-per-connection Pseudo Code Echo Server</h3>
<pre>
	
    ServerSocket serverSocket = new ServerSocket(8080);
    while (true) {
        Socket socket = serverSocket.accept();
        new Thread() {
            byte[] buffer = socket.read();
            socket.write(buffer);
        }.start();
    }
		
</pre>
	</article>

    <article class='fill'>
		<img src="images/honda-air-concept-03.jpg" />
	    <h3>Event-driven Architecture</h3>
    </article>

	<article>
		<h3>Event-driven Architecture</h3>
		<ul class="build">
			<li>More scalable alternative to thread-per-connection architecture</li>
			<li>Single thread handles multiple network connections</li>
			<li>Uses reactor pattern for demultiplexing</li>
			<li>Nginx, Twisted, EventMachine, Grizzly, Netty, Node.js, etc.</li>
		</ul>
	</article>

	<article>
		<h3>Event-driven Psuedo Code</h3>
<pre>
	
    ServerSocket serverSocket = new ServerSocket(8080);
    Set&lt;Socket&gt; sockets = new Set();
    sockets.add(serverSocket);
    while (1) {
        event = select(sockets);
        if (event is connectionEvent) {
            sockets.add(event.socket);
        }
        processEvent(event);
    }
 
</pre>
	</article>

	<article>
		<h3>Event-driven Architecture Myths</h3>
		<ul class="build">
			<li>Thread scheduling and context switching are expensive</li>
			<li>Event-driven servers are always faster</li>
			<li>Threads need 2MB of physical memory for their stack</li>
			<li>Thread-per-connection servers can't scale (Tomcat runs with 32,000 threads on my box)</li>
		</ul>
	</article>

	<article>
		<h3>When to use an event-driven architecture?</h3>
		<ul class="build">
			<li>Front-end server that does mostly pass-through work</li>
			<li>Long-lived network connections that are often idle
				<ul>
					<li>Web sockets</li>
					<li>Comet</li>
				</ul>
			</li>
		</ul>
	</article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Enough Talk ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/fight.png" />
	    <h3>Enough talk, let's fight</h3>
    </article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Node Introduction ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/nodejs-900x675.png" />
    </article>

    <article class=''>
		<img src="images/node.js-logo_270x71.png" class='center xlow'/>
    </article>

    <article class=''>
		<img src="images/nodejs4.png" class='center mid'/>
    </article>

    <article class=''>
		<img src="images/node_f.png" class='center low'/>
    </article>

	<article>
		<h3>Node.js</h3>
		<ul class="build">
			<li>Set of libraries on top of V8 to do networking things</li>
			<li>Almost no function in Node directly performs I/O, so the process never blocks.</li>
			<li>Node can do a lot of things at once</li>
		</ul>
	</article>

	<article>
		<h3>Node.js - Why JavaScript?</h3>
		<ul class="build">
			<li>JavaScript is non-blocking</li>
			<li>The web runs JavaScript</li>
			<li>Why not?</li>
		</ul>
	</article>

	<article>
		<h3>Node.js - Command Line</h3>
		<ul class="build">
			<li>process.pid</li>
			<li>process.platform</li>
			<li>process.versions</li>
			<li>process.memoryUsage()</li>
		</ul>
	</article>

	<article>
		<h3>Node Scripts</h3>
<pre>
 
    setTimeout(function() {
	    console.log("world");
    }, 1000);
    console.log("hello");
 
</pre>
	</article>
	
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Netty Introduction ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<article class='biglogo'>
		<!-- TODO Add Node.js logo -->
		<img src="images/netty_logo_600px.svg" />
	</article>

	<article>
		<h2>Netty</h2>
	</article>

	<article>
		<h3>Netty History</h3>
		<ul class="build">
			<li>Started in 2003</li>
			<li>Migrated to Apache Software Foundation as Apache MINA</li>
			<li>Left Apache and moved to Red Hat/JBoss in 2008</li>
			<li>Twitter currently employs most Netty contributors</li>
		</ul>
	</article>
	
	<article>
		<h3>Netty Architecture</h3>
		<div style="margin: 25px;   ">
			<img src="images/netty-architecture.png" width="100%" />
		</div>
	</article>

	<article>
		<h3>Key Netty Features</h3>
		<ul class="build">
			<li>Unified event API for Sockets, UDP, SCTP, Infiniband</li>
			<li>Minimizes memory copies</li>
			<li>Fair read/write ratio</li>
			<li>Customizable thread model</li>
		</ul>
	</article>

	<article>
		<h3>Netty Pipeline</h3>
		<div style="margin: 25px; text-align: center">
			<img src="images/netty_pipeline_after.png" height="90%" />
		</div>
	</article>

	<article>
		<h2>Netty Demo</h2>
	</article>

	<article>
		<h3>Projects built on Netty</h3>
		<ul>
			<li>Vert.x (formerly Node.x)</li>
			<li>Akka - Scala distributed actor based framework</li>
			<li>Netty Tools - Simplifies common tasks in Netty</li>
			<li>AsyncHttpClient - Written by Jean-Francois Arcand (creator of Grizzly)</li>
			<li>ADBCJ - Asynchronous Database Client</li>
			<li>Play - Scala based web framework</li>
			<li>PS3 Media Server</li>
		</ul>
	</article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Threading: Netty ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/thread.jpg" />
	    <h3>Threading</h3>
    </article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Threading Rebuttal: Node ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/tangle.jpg" />
	    <h3>Threading Rebuttal</h3>
    </article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Simplicity: Node ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/piece-of-cake.jpg" />
	    <h3>Simplicity</h3>
    </article>

	<article>
		<h3>Node Scripts</h3>
<pre>

    setTimeout(function() {
	    console.log("world");
    }, 1000);
    console.log("hello");
 
</pre>
	</article>
	
	<article>
		<h3>Classical Java Equivalent</h3>
<pre>
 
    try {
	    System.out.println("hello");
	    Thread.sleep(1000);
	    System.out.println("world");
    }
    catch(InteruptedException ie) {
	    //If this thread was interrupted by another thread 
    }
 
</pre>
	</article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Simplicity Rebuttal: Netty ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
        <img src="images/bugatti-engine.jpg" />
        <h3>Simplicity Rebuttal</h3>
    </article>

    <article>
        <h3>Is Node really simpler?</h3>
        <ul>
            <li>Threads can certainly be complicated</li>
            <li>Purely event-driven code can be even more complicated</li>
        </ul>
    </article>

    <article>
        <h3>Example Twitter client in Node</h3>
<pre>
    function handleRequest(req, resp) {
        var userId = getUserId(req);
        lookupTwitterId(userId,
            function(twitterId, consumerKey, consumerSecret) {
                cache.lookup(twitterId, function(result)) {
                    if (result) {
                        sendTwitterStream(resp, result);
                    } else {
                        var twit = new twitter({consumer_key: ... });
                        twit.stream('user', function(stream) {
                            sendTwitterStream(resp, stream);
                            cache.put(twitterId, stream);
                        });
                    }
                }
            });
    }
</pre>
    </article>

    <article>
        <h3>There's a problem with our Node example...</h3>
        <h2>What do we do if something fails?</h2>
    </article>
    
    <article>
        <h3>Revised Twitter client in Node</h3>
<pre>
    function handleRequest(req, resp) {
        var userId = getUserId(req);
        lookupTwitterId(userId,
            function(error, twitterId, consumerKey, consumerSecret) {
                if (error) { sendErrorResponse(error, resp); }
                cache.lookup(twitterId, function(error, result)) {
                    if (error) { sendErrorResponse(error, resp); }
                    if (result) {
                        sendTwitterStream(resp, result);
                    } else {
                        var twit = new twitter({consumer_key: ... });
                        twit.stream('user', function(error, stream) {
                            if (error) { sendErrorResponse(error, resp); }
                            sendTwitterStream(resp, stream);
                            cache.put(twitterId, stream, 300);
                        });
                    }
                }
            });
    }
</pre>
    </article>

    <article>
        <h3>Netty Gives You More Options</h3>
        <ul>
            <li>Netty isn't constrained to a single model for concurrency</li>
            <li>Has a powerful event-driven model where scalability is needed</li>
            <li>Lets you step down to an imperative model for simplicity using threads</li>
        </ul>
    </article>

    <article>
        <h3>Example Twitter Client in Netty</h3>
<pre>
    public void handleRequest(HttpRequest req, Channel channel) {
        try {
            String userId = getUserId(req);
            TwitterCredentials creds = lookupTwitterCreds(userId);
            Twitter twitter = new TwitterTemplate(creds);
            Stream stream = fetchStream(userId, twitter);
            sendTwitterStream(channel, stream);
        } catch (Exception e) {
            sendErrorResponse(e, channel);
        }
    }
    
    @ResponseCache(lifetime=300)
    Stream fetchStream(@CacheKey String userId, Twitter twitter) {
        return twit.userStream();
    }
</pre>
    </article>
    
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Performance: Netty ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/bugatti-veyron.jpg" />
	    <h3>Performance</h3>
    </article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Performance Rebuttal: Node ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/honda-bike.jpg" />
	    <h3>Performance Rebuttal</h3>
    </article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Problem Fit: Node ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/honda-indy-car.JPG" />
	    <h3>Right Tool: Language Fit</h3>
    </article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Problem Fit Rebuttal: Netty ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/audi-shark.JPG" />
	    <h3>Right Tool Rebuttal: Language Fit</h3>
    </article>

    <article>
        <h3>Netty is Not Limited to the Java Language</h3>
        <ul>
            <li>Many different languages run on the JVM</li>
            <li>Scala and Clojure are probably even better than JavaScript for writing event-driven code</li>
            <li>Node doesn't have a monopoly on server-side JavaScript (JavaScript runs on the JVM too!)</li>
        </ul>
    </article>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Conclusion ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

    <article class='fill'>
		<img src="images/excavator.jpg" />
	    <h3>Conclusion</h3>
    </article>







	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~ Old Stuff ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->



<!-- - Keep this stuff for now - - -

	<article>
		<h3>Node Web Server</h3>
<pre>
var http = require('http');

var s = http.createServer(function(req, res) {
	res.writeHead(200, {'content-type': 'text/plain'});
	res.end("hello world!");
});

s.listen(8000);
</pre>
	</article>

	<article>
		<h3>Node Chat Client</h3>
<pre>
var net = require('net'), sockets = [];
var s = net.Server(function(socket) {
    sockets.push(socket);
    socket.on('data', function(d) {
        for (var i = 0; i < sockets.length; i++) {
            if (sockets[i] == socket) continue;
            sockets[i].write(d);
        }
    });
    socket.on('end', function() {
        var i = sockets.indexOf(socket);
        sockets.splice(i, 1);
    });
});
s.listen(8089);
</pre>
	</article>

	<article class='fill'>
		<h3>Node Inspector</h3>
		<img src="images/overview.png" />
	</article>
	
	<article class='fill'>
		<h3>Node Inspector</h3>
		<img src="images/heap.png" />
	</article>
	
	<article>
		<h3>Modules</h3>
		<ul class="build">
			<li>npm</li>
			<li>socket.io</li>
			<li>express</li>
			<li>hundreds more</li>
		</ul>
	</article>

	<article>
		<h3>Modules Examples</h3>
		<ul class="build">
			<li>Templating: 45</li>
			<li>Build/Deployment: 31</li>
			<li>Message Queues: 5</li>
			<li>Testing Frameworks: 47</li>
			<li>Compression: 12</li>
			<li>I18n and L10n: 10</li>
		</ul>
	</article>

	<article>
		<h3>Documentation</h3>
		<ul class="build">
			<li>Good API Documentation</li>
			<li>7 free node.js books</li>
		</ul>
	</article>

	<article>
		<h2>Non-blocking Java</h2>
	</article>

	<article>
		<h3>Brian Goetz: A non-blocking counter</h3>
<pre>
public class NonblockingCounter {
    private AtomicInteger value;

    public int getValue() {
        return value.get();
    }

    public int increment() {
        int v;
        do {
            v = value.get();
        }
         while (!value.compareAndSet(v, v + 1));
        return v + 1;
    }
}
</pre>		
	</article>
	
	<article>
		<h3>Brian Goetz: A non-blocking stack</h3>
<pre class='small'>
public class ConcurrentStack<E> {
    AtomicReference&lt;Node&lt;E&gt;&gt; head = new AtomicReference&lt;Node&lt;E&gt;&gt;();

    public void push(E item) {
        Node&lt;E&gt; newHead = new Node&lt;E&gt;(item);
        Node&lt;E&gt; oldHead;
        do {
            oldHead = head.get();
            newHead.next = oldHead;
        } while (!head.compareAndSet(oldHead, newHead));
    }

    public E pop() {
        Node&lt;E&gt; oldHead;
        Node&lt;E&gt; newHead;
        do {
            oldHead = head.get();
            if (oldHead == null) 
                return null;
            newHead = oldHead.next;
        } while (!head.compareAndSet(oldHead,newHead));
        return oldHead.item;
    }

    static class Node&lt;E&gt; {
        final E item;
        Node&lt;E&gt; next;

        public Node(E item) { this.item = item; }
    }
}
</pre>
	</article>
	
	<article>
		<h3>Brian Goetz: Non-blocking thread complexity</h3>
		<p>The examples so far -- counter and stack -- are very simple nonblocking algorithms and are easy to follow once you grasp the pattern of using CAS in a loop. For more sophisticated data structures, nonblocking algorithms are <em>much</em> more complicated than these simple examples because modifying a linked list, tree, or hash table can involve updating more than one pointer.</p>
	</article>
	
	<article>
		<h3>Brian Goetz: Performance Considerations</h3>
		<p>Under light to moderate contention, nonblocking algorithms tend to outperform blocking ones because most of the time 	the CAS succeeds on the first try, and the penalty for contention when it does occur does not involve thread suspension and context switching, just a few more iterations of the loop. An uncontended CAS is less expensive than an uncontended lock acquisition (this statement has to be true because an uncontended lock acquisition involves a CAS plus additional processing), and a contended CAS involves a shorter delay than a contended lock acquisition.</p>
		<p>Under high contention -- when many threads are pounding on a single memory location -- lock-based algorithms start to offer better throughput than nonblocking ones because when a thread blocks, it stops pounding and patiently waits its turn, avoiding further contention. However, contention levels this high are uncommon, as most of the time threads interleave thread-local computation with operations that contend for shared data, giving other threads a chance at the shared data. (Contention levels this high also indicate that reexamining your algorithm with an eye towards less shared data is in order.) The graph in "Going atomic" was somewhat confusing in this regard, as the program being measured was so unrealistically contention-intensive that it appeared that locks were a win for even small numbers of threads.</p>
	</article>
	
<-->
</section>

</body>
</html>
